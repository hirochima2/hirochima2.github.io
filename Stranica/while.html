<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="header.js"></script>
    <title>WHILE</title>
</head>
<body>
    <script src="preuzimanje.js"></script>
    <script src="nav.js"></script>
    <script src="dropdownmn.js"></script>
    <div id="main" class="main">
        <section class="glavni-sektsn">
            <button class="openbtn" onclick="otvoriNavBar()">&#9776; Otvori Meni</button>
            <header>WHILE petlja</header>
            <p>
                U prošlom poglavlju smo spomenuli primjer petlje. Sada ćemo malo detaljnije o njemu.
                <ul>
                    <li>Uzmi cipelu</li>
                    <li><strong>Sve dok</strong> Pepeljuga nije nađena: 
                    <ul>
                        <li>Potraži prvu sljedeću djevojku</li>
                        <li>Probaj može li obući cipelu</li>
                        <li><strong>Ako</strong> cipela odgovara: 
                        <ul>
                            <li>Pepeljuga je nađena</li>
                        </ul></li>
                    </ul></li>
                    <li>Oženi se</li>
                </ul>
            </p>
            <p>
                Princ ne zna unaprijed koliko će djevojaka morati da ispita prije nego sto nađe pravu. Kada pri izvršavanju ovog algoritma naiđemo na specijalnu frazu “Sve dok”, ispituje se tačnost uvjeta koji slijedi. Ukoliko je uvjet ispunjen, naredbe unutar petlje (prikazane uvučeno) se izvršavaju. Nakon što se sve naredbe unutar petlje izvrše jedanput, izvođenje petlje započinje ispočetka. Preciznije, uvjet se ispituje ponovo, i ukoliko je još uvijek ispunjen, naredbe unutar petlje se izvršavaju ponovo. Postupak se dalje ponavlja sve dok navedeni uvjet ne prestane biti tačan. Nakon toga, tijelo petlje se preskače, i izvršavanje algoritma se nastavlja od prve naredbe iza tijela petlje. Analogna upravljačka struktura koja vrši ponavljanje skupine naredbi sve dok je neki uvjet ispunjen u jeziku C++ realizira se pomoću naredbe “while”. Ona se koristi u sljedećem obliku:
                <pre><code class="language-cpp">while(izraz) naredba</code></pre>
            </p>
            <p>
                Primijetimo da je struktura naredbe “while” praktično identična strukturi naredbe “if”. Ipak, njihov smisao se bitno razlikuje. Slično kao naredbe “if”, i kod naredbe “while” izraz u zagradi bi trebao da predstavlja uvjet (odnosno trebao bi biti logičkog tipa), a prihvata se i izraz proizvoljnog numeričkog tipa (koji se tom prilikom konvertira u logički, po ranije opisanim pravilima). Ukoliko uvjet nije tačan, naredba navedena iza zagrada se preskače (i izvođenje programa se nastavlja od sljedeće naredbe), a u protivnom se izvršava. Po ovome se naredba “while” ponaša tačno kao i naredba “if”. Međutim, nakon što se naredba navedena iza zagrada izvrši, izraz (uvjet) se ponovo izračunava, i ukoliko je on i dalje tačan, navedena naredba se ponovo izvršava. Postupak se ponavlja sve dok je uvjet naveden u zagradi tačan. Tek kada uvjet postane netačan, program se nastavlja izvršavati od sljedeće naredbe. Dakle, kod naredbe “if”, pripadna naredba koja slijedi iza zagrada se izvršava ako je uvjet tačan, a kod naredbe “while”, pripadna naredba koja slijedi iza zagrada (za koju kažemo da čini tijelo petlje) se neprestano izvršava sve dok je uvjet tačan. Obratimo pažnju da naredba “if” ne tvori petlju! Ukoliko želimo da ponavljamo veću skupinu naredbi, odnosno ukoliko želimo da se tijelo petlje sastoji od više naredbi, prosto ćemo naredbe koje čine tijelo petlje objediniti u blok, s obzirom da smo rekli da se sa aspekta orkuženja u kojem se nalazi blok, čitav blok tretira kao jedna naredba.
            </p>
            <p>
                Kako se kod naredbe “while” tijelo petlje izvršava sve dok je navedeni uvjet ispunjen, slijedi da bi petlja imala smisla, makar negdje unutar njenog tijela trebala bi se nalaziti neka naredba koja će promijeniti vrijednost barem neke od promjenljivih koje se pojavljuju unutar navedenog uvjeta. U suprotnom, ukoliko je uvjet pri ulasku u petlju bio tačan, takav će sigurno i ostati, pa se petlja nikad neće završiti, odnosno tijelo petlje će se izvršavati unedogled (odnosno, dok na neki način nasilno ne prekinemo izvršavanje programa). Ovo je naročito česta greška koja se javlja u programima koji sadrže petlje, pogotovo kod početnika.
            </p>
            <p>
                Sljedeći primjer prikazuje program koji omogućava korisniku da unosi nenegativne cijele brojeve i pamti ukupnu sumu unesenih brojeva. Kada se unese negativan broj, program ispisuje izračunatu sumu (ne računajući i taj negativan broj) i završava sa radom. Ideja programa se zasniva u uvođenju neke promjenljive (nazovimo je npr. “suma”) koja će pamtiti trenutnu sumu (odnosno sumu prethodno unesenih brojeva), a čija će početna vrijednost biti nula. Svaki put kada unesemo novi broj, njega samo nadodajemo na trenutnu vrijednost sume. Postupak se ponavlja sve dok su uneseni brojevi nenegativni:
                <pre data-src="C++/loop/loop1.cpp" data-download-link data-download-link-label="Preuzmite!" class="line-numbers"><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main(){
    int broj;
    cout << "Unesite brojeve koji ce se sabirati " << "- negativan broj oznacava prekid." << endl << endl;
    cout << "Unesite broj: "; 
    cin >> broj;
    int suma(0); 
    while(broj >= 0) {
          suma += broj; 
          cout << "Unesite broj: ";
          cin >> broj;
    }
    cout << "\nSuma unesenih brojeva je: " << suma << endl;
    return 0;

}</pre></code>
            </p>
            <p>
                Iskoristimo sada naredbu “while” za rješavanje problema računanja sume recipročnih vrijednosti svih prirodnih brojeva od 1 do n, pri čemu je n broj koji se unosi sa tastature (problem postavljen na početku ovog poglavlja je specijalan slučaj ovog problema za n=1000000). Rješenje ovog problema dato je sljedećim programom koji je dovoljno jasan sam po sebi :
                <pre data-src="C++/loop/loop2.cpp" data-download-link data-download-link-label="Preuzmite!" class="line-numbers"><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main(){
    int n;
    cout << "Unesite n: ";
    cin >> n;
    double suma(0);
    int i(1);
    while (i <= n) {
        suma += 1 / i;
        i++;
    }
    cout << "Suma reciprocnih vrijednosti brojeva od 1 do " << n << " iznosi " << suma << endl;
    return 0 ;
}</pre></code>
            </p>
            <p>
                Obratimo pažnju na tačku unutar broja u izrazu “1. / i”. Ukoliko bismo izostavili ovu tačku, kao krajnji rezultat bismo dobili nulu, jer bi operator “/” bio shvaćen kao operator cjelobrojnog dijeljenja, s obzirom da je “i” cjelobrojna promjenljiva (tako da bi oba operanda bila cjelobrojnog tipa). Stoga još jednom ukazujemo na potrebu posebnog opreza pri korištenju operatora “/”!
            </p>
            <p>

Razmotrimo sada kako bismo mogli ostvariti bolju kontrolu nad ulaznim tokom. Već smo ranije rekli da u slučaju da korisnik sa tastature unese neočekivani podatak (npr. tekst kada se očekuje broj), ulazni tok dospijeva u neispravno stanje, i svaka dalja upotreba ulaznog toka biće ignorirana, sve dok tok ne vratimo u ispravno stanje (pozivom funkcije “cin.clear”. U narednom primjeru ćemo iskoristiti “while” petlju sa ciljem ponavljanja unosa sve dok unos ne bude ispravan:
<pre class="line-numbers"><code class="language-cpp">int broj;
cout << "Unesite broj: ";
cin >> broj;
while (!cin){
    cout << "Nemojte se saliti, unesite broj!" << endl;
    cin.clear();
    cin.ignore(10000, '\n'');
    cin >> broj;
}
cout << "U redu, unijeli ste broj " << broj << endl;</code></pre>
            </p>
            <p>
                Rad ovog isječka je prilično jasan. Ukoliko je nakon zahtijevanog unosa broja zaista unesen broj, ulazni tok će biti u ispravnom stanju, uvjet “!cin” neće biti tačan, i tijelo “while” petlje neće se uopće ni izvršiti. Međutim, ukoliko tok dospije u neispravno stanje, unutar tijela petlje ispisujemo poruku upozorenja, vraćamo tok u ispravno stanje, uklanjamo iz ulaznog toka znakove koji su doveli do problema (pozivom funkcije “cin.ignore”), i zahtijevamo novi unos. Nakon toga, uvjet petlje se ponovo provjerava, i postupak se ponavlja sve dok unos ne bude ispravan (tj. sve dok uvjet “!cin” ne postane netačan).
            </p>
            <p>
                Demonstriraćemo još jedan interesantan primjer gdje je korisno imati bočni efekat unutar uvjeta petlje. Pretpostavimo da želimo napisati program koji će tražiti od korisnika unos neke rečenice, a koji će zatim ponoviti istu rečenicu pretvarajući svako malo slovo u veliko. Kako ne znamo unaprijed koliko će rečenica imati znakova, znakove ćemo čitati u petlji, koja će se izvršavati sve dok se ne dostigne oznaka za kraj reda, tj. kontrolni znak '\n'. Znakove ćemo čitati pozivom funkcije “cin.get”, s obzirom da operator izdvajanja “>>” ignorira razmake i oznaku kraja reda, kao što smo već ranije napomenuli. Stoga bi traženi program mogao izgledati poput sljedećeg:
                <pre data-src="C++/loop/loop3.cpp" data-download-link data-download-link-label="Preuzmite!" class="line-numbers"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cctype&gt;

using namespace std;
int main(){
    cout << "Unesite recenicu: ";
    char znak = cin.get();
    while(znak != '\n') {
        cout << (char)toupper(znak);
        znak = cin.get();
    }
    cout << endl;
    return 0;
}</pre></code>
            </p>
            <p>Mogući scenario izvršavanja ovog programa: 
                <pre><code class="language-plain">Unesite recenicu:
Ne sam, Safete!
NE SAM, SAFETE!</code></pre>
            </p>
            <button class="openbtn" onclick="otvoriNavBar()">&#9776; Otvori Meni</button>
            <p>

            </p>
            </section>
            </div>
</body>
</html>